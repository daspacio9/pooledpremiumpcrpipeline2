# \HEADER\-------------------------------------------------------------------------
#
#  CONTENTS      : Snakemake nanopore data pipeline
#
#  DESCRIPTION   : Alignment of the subreads onto the consensus generated by Medaka, pileup and plotting for QC reporting.
#
#  RESTRICTIONS  : none
#
#  REQUIRES      : none
#
# ---------------------------------------------------------------------------------


# Helper function that determines which files are produced by the split_fastq checkpoint
# -----------------------------------------------------
def get_split_coverage(wildcards):
    # 1. Ensure the checkpoint has finished
    checkpoint_output = checkpoints.split_fastq.get(**wildcards).output[0]
    print(checkpoint_output)
    # 2. List the files that were actually created
    # This glob_wildcards looks inside the directory produced by the checkpoint
    filenames = glob_wildcards(os.path.join(checkpoint_output, "{sample}_consensus.fastq")).sample
    print(filenames)
    # 3. Return the full paths to the next rule
    return expand(".coverage_{sample}.done", sample=filenames)

# Helper function that determines which files are produced by the split_fastq checkpoint
# -----------------------------------------------------
def get_split_plots(wildcards):
    # 1. Ensure the checkpoint has finished
    checkpoint_output = checkpoints.split_fastq.get(**wildcards).output[0]
    # 2. List the files that were actually created
    # This glob_wildcards looks inside the directory produced by the checkpoint
    filenames = glob_wildcards(os.path.join(checkpoint_output, "{sample}_consensus.fastq")).sample
    print(filenames)
    # 3. Return the full paths to the next rule
    return expand(".plot_{sample}.done", sample=filenames)

### Alignment to the consensus and coverage, consensus match calculation rules and plotting thereof
# -----------------------------------------------------
rule aln_to_consensus:
    input:
        consensus = "consensus_split/{sample}_consensus.fastq",
        reads = "demux/{sample}.fastq.gz"
    output:
        sam = "aln/{sample}_aln.sam",
        bam = "aln/{sample}_aln.bam",
        sorted_bam = "aln/{sample}_aln_sorted.bam",
        bai = "aln/{sample}_aln_sorted.bam.bai",
        cov = "report/{sample}_coverage.txt",
        pileup = "report/{sample}_mpileup.txt",
        coverage_flag = touch(".coverage_{sample}.done") 
    log:
        "logs/aln/{sample}_aln.log"
    shell:
        # Now use named inputs for clarity and safety!
        r"""
        minimap2 -ax map-ont {input.consensus} {input.reads} > {output.sam} 2>> {log}
        samtools view -bo {output.bam} {output.sam} 2>> {log}
        samtools sort {output.bam} -o {output.sorted_bam} 2>> {log}
        samtools index {output.sorted_bam} 2>> {log}
        samtools depth -a -o {output.cov} {output.sorted_bam} 2>> {log}
        samtools mpileup -a -f {input.consensus} {output.sorted_bam} > {output.pileup} 2>> {log}
        """


rule parse_mpileup_ref_match:
    input:
        "report/{sample}_mpileup.txt"
    output:
        "report/{sample}_pypileup.tsv"
    run:
        import pandas as pd
        from common import parse_mpileup
        df_pileup = parse_mpileup(input[0])

        df_pileup.to_csv(output[0], sep='\t', index=False)


rule plot_coverage:
    input:
        "report/{sample}_pypileup.tsv"
    output:
        report("report/{sample}_coverage.pdf", category = "{sample}"), 
        report("report/{sample}_mismatch_freq.pdf", category = "{sample}"),
        plot_flag = ".plot_{sample}.done", #flag file
    run:
        import pandas as pd
        import matplotlib
        matplotlib.use('Agg')
        import matplotlib.pyplot as plt
        # Read coverage data
        # Read reference match data
        df_ref = pd.read_csv(input[0], sep="\t")
        df_ref['freq_mismatch'] = (df_ref['coverage'] - df_ref['ref_match']) / df_ref['coverage']
        df_ref['freq_mismatch'] = df_ref['freq_mismatch'].fillna(1)  # Handle NaN values if coverage is 0, set freq_mismatch to 1
        # Plot coverage
        # Fill the area between the curve and the x-axis (y=0)
        
        plt.figure(figsize=(10, 4))
        plt.plot(df_ref["pos"], df_ref["coverage"], color='blue', linewidth=0.2)
        plt.plot(df_ref["pos"], df_ref["ref_match"], color='green', linewidth=0.4, alpha=0.5)
        plt.title(f"Coverage Plot for {wildcards.sample}")
        plt.xlabel("Position")
        plt.ylabel("Depth")
        plt.yscale("linear")
        plt.ylim(0, round(df_ref["coverage"].max()*1.1))  # Add some headroom
        plt.legend(["Coverage", "Ref Match"])
        plt.grid(False)
        plt.savefig(output[0])
        plt.close()

        # Plot frequency of mismatches
        plt.figure(figsize=(10, 4))
        plt.plot(df_ref["pos"], df_ref["freq_mismatch"], color='red', linewidth=0.5)
        plt.fill_between(df_ref["pos"], df_ref["freq_mismatch"], color='red', alpha=0.3)
        plt.title(f"Substitution Plot for {wildcards.sample}")
        plt.xlabel("Position")
        plt.ylabel("freq")
        plt.yscale("linear")
        plt.ylim(0, (df_ref["freq_mismatch"]).max()*1.1)
        plt.legend(["freq_mismatch"])
        plt.grid(False)
        plt.savefig(output[1])
        plt.close()
        with open(output.plot_flag, "w") as _f: _f.write("Plotting completed.\n")

rule coverage_done:
    input:
        get_split_coverage
    output:
        touch(".coverage.done")
    run:
        with open(output[0], "w") as f:
            f.write("Coverage calculation completed.\n")

rule plot_done:
    input:
        get_split_plots
    output:
        touch(".plot.done")
    run:
        with open(output[0], "w") as f:
            f.write("Coverage plotting completed.\n")
